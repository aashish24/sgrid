{
    "docs": [
        {
            "location": "/", 
            "text": "SGRID Conventions (v0.2)\n\uf0c1\n\n\nFollowing the success of the \nUGRID conventions\n,\nBert Jagers created conventions for staggered data on structured grids that are consistent with the UGRID conventions.\nWe refer to these as the SGRID conventions, described below.\n\n\nIntroduction\n\uf0c1\n\n\nThe \nCF-conventions\n are widely used for storing and distributing environmental / earth sciences / climate data. The CF-conventions use a data perspective: every data value points to the latitude and longitude at which that value has been defined; the combination of latitude and longitude bounds and cell methods attributes can be used to define spatially averaged rather than point values. \n\n\nThis is all great for the distribution of (interpolated) data for general visualization and spatial data processing,\nbut it doesn\nt capture the relationship of the variables as computed by a numerical model (such as \nArakawa staggering\n). Many models use staggered grids (using finite differences, or finite volume approach) or use a finite element approach of which the correct meaning may not be captured easily by simple cell methods descriptors.\nThis becomes a problem if you don\nt want to just look at the big picture of the model results,\nbut also at the details at the grid resolution:\n\n What is the exact meaning of a flux on the output file in discrete terms?\n\n Can we verify the mass balance?\n* Can the data be used for restarting the model?\n\n\nCorrectly handling the staggered data has always been a crucial element of model post-processing tools. In the UGRID conventions, we have defined the (unstructured) grid as a separate entity on the file which consists of nodes and connections of nodes defining edges, faces, and volumes.\nFor a structured (staggered) grid we are currently lacking a consistent convention. Although one could store structured grid data using UGRID conventions,\nsome fundamental aspects such as distinction between grid directions would be lost.\n\n\nIn this context we have created these lightweight SGRID conventions to define the core aspects of a structured staggered grid without trying to capture the details of finite element formulations.\nThis is an attempt to bring conventions for structured grids on par with those for unstructured grids.\n\n\nConventions\n\uf0c1\n\n\nConsistent with the UGRID conventions we use the following terms for points,\nlines, and cells that make up a grid.\n\n\n\n\n\n\n\n\nDimensionality\n\n\nName\n\n\nComments\n\n\n\n\n\n\n\n\n\n\n0\n\n\nnode\n\n\nA point, a coordinate pair or triplet: the most basic element of the topology (also known as \nvertex\n).\n\n\n\n\n\n\n1\n\n\nedge\n\n\nA line or curve bounded by two nodes.\n\n\n\n\n\n\n2\n\n\nface\n\n\nA plane or surface enclosed by a set of edges. In a Cartesian 2D model, you might refer to this as a \ncell\n or \nsquare\n.\n\n\n\n\n\n\n3\n\n\nvolume\n\n\nA volume enclosed by a set of faces.\n\n\n\n\n\n\n\n\nIn the UGRID conventions the focus is on describing the topology of the mesh (connectivity of the nodes, edges, faces, and volumes as appropriate).\nThe topology of a structured grid is inherently defined;\nthe focus for the SGRID conventions is therefore on the numbering used.\nStill we need to distinguish between 2D and 3D grids (1D conventions may be defined consistently).\n\n\n2D grid\n\uf0c1\n\n\n\n\n\n\n\n\nRequired topology attributes\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nvertical_dimensions\n\n\n\n\n\n\n\n\ntopology_dimension\n\n\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOptional attributes\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nnode_dimensions\n\n\nnode_dimension1 node_dimension2\n\n\n\n\n\n\nnode_coordinates\n\n\n\n\n\n\n\n\nface_dimensions\n\n\nface_dimension1:node_dimension1 (padding:\ntype1\n) face_dimension2:node_dimension2 (padding:\ntype2\n)\n\n\n\n\n\n\nface_coordinate\n\n\n\n\n\n\n\n\nedge2_dimensions\n\n\nface_dimension1:node_dimension1 (padding:\ntype1\n) node_dimension2\n\n\n\n\n\n\nedge2_coordinates\n\n\n\n\n\n\n\n\nedge1_dimensions\n\n\nnode_dimension1 face_dimension2:node_dimension2 (padding:\ntype2\n)\n\n\n\n\n\n\nedge1_coordinates\n\n\n\n\n\n\n\n\ncf_role\n\n\ngrid_topology\n\n\n\n\n\n\n\n\nwhere the padding type may be one of the four literal strings:\n\nnone\n, \nlow\n, \nhigh\n, or \nboth\n depending on whether the face_dimension is one shorter than the corresponding node_dimension (padding:none),\none longer than the corresponding node_dimension (padding:both),\nor of equal length with one extra value stored on the low or high end of the dimension (see the figure below).\nThe edge1_dimensions and edge2_dimensions attributes may be used to define separate dimensions for the edges (see the ROMS example below),\nbut by default the edge dimensions are assumed to be consistent with the dimensions used by the edges and faces respectively.\nThe optional vertical_dimensions attribute may be used to specify the names of the dimensions for the layers and layer interfaces respectively using the same syntax:\nlayer_dimension:layer_interface_dimension (padding:\ntype\n).\n\n\nNote:\n\n\n\n\nThe numbering of the edges corresponds to the order of the dimensions in the dimensions attributes.\n  The order of the dimensions listed here does not change since these are specified as a string.\n  The actual order of dimensions in the netCDF API (and hence in the dump generated by different tools) depends on the programming language used.\n  Hence, the order of the dimensions listed here may differ from the order of the dimensions in the data definition.\n\n\n\n\n\nFigure 1: illustrating the formulations used for expressing the relationship between face/edge and node dimensions. Please note that the numbering of the faces and nodes can be adjusted using face(face) and node(node) coordinate variables.\n\n\nExample:\n\n\ndimensions:\n    time = UNLIMITED ;\n    inode = 10 ;\n    jnode = 20 ;\n    icell = 9 ;\n    jcell = 19 ;\n\nvariables:\n    char time(time) ;\n        time:standard_name = \ntime\n ;\n        time:long_name = \ntime\n ;\n        time:units = \nseconds since 2015-01-01 00:00:00\n ;\n    float u(time, jcell, inode) ;\n        u:description = \nx-velocity\n ;\n        u:units = \nm s-1\n ;\n        u:grid = \nMyGrid\n ;\n        u:location = \nedge1\n ;\n    float v(time, jnode, icell) ;\n        u:description = \ny-velocity\n ;\n        u:units = \nm s-1\n ;\n        u:grid = \nMyGrid\n ;\n        u:location = \nedge2\n ;\n    float c(time, jcell, icell) ;\n        c:description = \nsome concentration\n ;\n        c:grid = \nMyGrid\n ;\n        c:location = \nface\n ;\n    float node_lat(jnode, inode) ;\n        node_lat:standard_name = \nlatitude\n ;\n        node_lat:units = \ndegree_north\n ;\n    float node_lon(jnode, inode) ;\n        node_lon:standard_name = \nlongitude\n ;\n        node_lon:units = \ndegree_east\n ;\n\n    int MyGrid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions = \ninode jnode\n ;\n        grid:face_dimensions = \nicell: inode (padding: none) jcell: jnode (padding: none)\n ;\n        grid:node_coordinates = \nnode_lon node_lat\n ;\n\n\n\n\n3D grid\n\uf0c1\n\n\n\n\n\n\n\n\nRequired topology attributes\n\n\nValue\n\n\n\n\n\n\n\n\n\n\ntopology_dimension\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOptional attributes\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nvolume_dimensions\n\n\nface_dimension1:node_dimension1 (padding:\ntype1\n) face_dimension2:node_dimension2 (padding:\ntype2\n) face_dimension3:node_dimension3 (padding:\ntype3\n)\n\n\n\n\n\n\nface3_dimensions\n\n\nface_dimension1:node_dimension1 (padding:\ntype1\n) face_dimension2:node_dimension2 (padding:\ntype2\n) node_dimension3\n\n\n\n\n\n\nedge1_dimensions\n\n\nface_dimension1:node_dimension1 (padding:\ntype1\n) node_dimension2 node_dimension3\n\n\n\n\n\n\nface2_dimensions\n\n\nface_dimension1:node_dimension1 (padding:\ntype1\n) node_dimension2 face_dimension3:node_dimension3 (padding:\ntype3\n)\n\n\n\n\n\n\ncf_role\n\n\ngrid_topology\n\n\n\n\n\n\nedge2_dimensions\n\n\nnode_dimension1 face_dimension2:node_dimension2 (padding:\ntype2\n) node_dimension3\n\n\n\n\n\n\nedge3_dimensions\n\n\nnode_dimension1 node_dimension2 face_dimension3:node_dimension3 (padding:\ntype3\n)\n\n\n\n\n\n\nnode_dimensions\n\n\nnode_dimension1 node_dimension2 node_dimension3\n\n\n\n\n\n\nface1_dimensions\n\n\nnode_dimension1 face_dimension2:node_dimension2 (padding:\ntype2\n) face_dimension3:node_dimension3 (padding:\ntype3\n)\n\n\n\n\n\n\nnode_coordinates\n\n\n\n\n\n\n\n\nedge\ni\n_coordinates\n\n\n\n\n\n\n\n\nface\ni\n_coordinates\n\n\n\n\n\n\n\n\nvolume_coordinates\n\n\n\n\n\n\n\n\n\n\nNotes:\n\n\n\n\nThe edge1, edge2, and edge3 are in a 3D grid aligned to the dimensions1, 2, and 3 respectively,\n  whereas the edge1 and edge2 are in a 2D grid perpendicular to the dimensions 1 and 2 respectively.\n  The face1, face2, and face3 play that role in the 3D grid.\n\n\nThe 3d grid option should not be used be used for layered grids,\n  such as typical ocean and atmosphere models.\n  Use the 2d grid with vertical dimensions instead.\n  This allows 2D quantities (such as surface quantities) and 3D quantities to be linked to the same mesh.\n\n\n\n\nExample:\n\n\ndimensions:\n    time = UNLIMITED ;\n    inode = 10 ;\n    jnode = 20 ;\n    knode = 30 ;\n    iface = 9 ;\n    jface = 19 ;\n    kface = 29 ;\n\nvariables:\n    char time(time) ;\n        time:standard_name = \ntime\n ;\n        time:long_name = \ntime\n ;\n        time:units = \nseconds since 2015-01-01 00:00:00\n ;\n    float u(time, kface, jface, inode) ;\n        u:description = \nx-velocity\n ;\n        u:units = \nm s-1\n ;\n        u:grid = \nMyGrid3\n ;\n        u:location = \nface1\n ;\n    float v(time, kface, jnode, iface) ;\n        u:description = \ny-velocity\n ;\n        u:units = \nm s-1\n ;\n        u:grid = \nMyGrid3\n ;\n        u:location = \nface2\n ;\n    float w(time, knode, jface, iface) ;\n        u:description = \nz-velocity\n ;\n        u:units = \nm s-1\n ;\n        u:grid = \nMyGrid3\n ;\n        u:location = \nface3\n ;\n    float c(time, kface, jface, iface) ;\n        c:description = \nsome concentration\n ;\n        c:grid = \nMyGrid3\n ;\n        c:location = \nvolume\n ;\n    float node_lat(knode, jnode, inode) ;\n        node_lat:standard_name = \nlatitude\n ;\n        node_lat:units = \ndegree_north\n ;\n    float node_lon(knode, jnode, inode) ;\n        node_lon:standard_name = \nlongitude\n ;\n        node_lon:units = \ndegree_east\n ;\n    float node_elevation(knode, jnode, inode) ;\n        node_elevation:description = \nelevation\n ;\n        node_elevation:units = \nm\n ;\n\n    int MyGrid3 ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 3 ;\n        grid:node_dimensions = \ninode jnode knode\n ;\n        grid:volume_dimensions = \niface: inode (padding: none) jface: jnode (padding: none) kface: knode (padding: none)\n ;\n        grid:node_coordinates = \nnode_lon node_lat node_elevation\n ;\n\n\n\n\nData variables\n\uf0c1\n\n\nThe use of the attributes to associate a data variable with a specific grid and stagger location is copied from the UGRID conventions:\nTo map the variable onto the topology of the underlying grid,\ntwo new attributes have been introduced.\nFirst, the attribute \ngrid\n points to the grid_topology variable containing the meta-data attributes of the grid on which the variable has been defined.\nSecond, the attribute \nlocation\n points to the (stagger) location within the grid at which the variable is defined.\n\n\nExample:\n\n\ndouble waterlevel(time,j,i) ;\n        waterlevel:standard_name = \nsea_surface_height_above_geoid\n ;\n        waterlevel:units = \nm\n ;\n        waterlevel:grid = \nMyGrid\n\n        waterlevel:location = \nface\n ;\n        waterlevel:coordinates = \nlat_face_MyGrid lon_face_MyGrid\n ;\n\n\n\n\nExamples\n\uf0c1\n\n\nDelft3D\n\uf0c1\n\n\nDelft3D uses an Arikawa C-grid with the water level (pressure) computed in the cell centres,\nand the normal velocities at the cell edges.\nThis example shows the use of asymmetric padding (at the low end of the horizontal coordinate indices there is an extra line of face/mid-point values).\nIn the vertical there is no padding, so the number of layer interfaces is one more than the number of layers.\nThe integer coodinate variables KMAX and KMAX1 are used to indicate that layer interfaces are numbered 0 to KMAX whereas all other indices use the default numbering from 1 to the maximum value.\n\n\nnetcdf trim-f34 {\ndimensions:\n    NMAX = 22 ;\n    NMAXZ = 22 ;\n    MMAX = 15 ;\n    MMAXZ = 15 ;\n    KMAX = 5 ;\n    KMAX1 = 6 ;\n    time = UNLIMITED ; // (6 currently)\nvariables:\n    int KMAX(KMAX) ;\n    int KMAX1(KMAX1) ;\n    float XCOR(MMAX, NMAX) ;\n        XCOR:standard_name = \nprojection_x_coordinate\n ;\n        XCOR:long_name = \nX-coordinate of grid points\n ;\n        XCOR:units = \nm\n ;\n    float YCOR(MMAX, NMAX) ;\n        YCOR:standard_name = \nprojection_y_coordinate\n ;\n        YCOR:long_name = \nY-coordinate of grid points\n ;\n        YCOR:units = \nm\n ;\n    float XZ(MMAXZ, NMAXZ) ;\n        XZ:standard_name = \nprojection_x_coordinate\n ;\n        XZ:long_name = \nX-coordinate of cell centres\n ;\n        XZ:units = \nm\n ;\n    float YZ(MMAXZ, NMAXZ) ;\n        YZ:standard_name = \nprojection_y_coordinate\n ;\n        YZ:long_name = \nY-coordinate of cell centres\n ;\n        YZ:units = \nm\n ;\n    float THICK(KMAX) ;\n        THICK:long_name = \nFraction part of layer thickness of total water-height\n ;\n        THICK:units = \n[ .01*% ]\n ;\n    float time(time) ;\n        time:standard_name = \ntime\n ;\n        time:long_name = \ntime\n ;\n        time:units = \nseconds since 1990-08-05 00:00:00\n ;\n    float S1(time, MMAXZ, NMAXZ) ;\n        S1:long_name = \nWater-level in zeta point\n ;\n        S1:units = \nm\n ;\n        S1:coordinates = \nXZ YZ\n ;\n        S1:grid = \ngrid\n ; // SGRID attribute\n        S1:location = \nface\n ; // SGRID attribute\n    float U1(time, KMAX, MMAX, NMAXZ) ;\n        U1:long_name = \nU-velocity per layer in U-point (Eulerian)\n ;\n        U1:units = \nm/s\n ;\n        U1:grid = \ngrid\n ; // SGRID attribute\n        U1:location = \nedge1\n ; // SGRID attribute\n    float V1(time, KMAX, MMAXZ, NMAX) ;\n        V1:long_name = \nV-velocity per layer in V-point (Eulerian)\n ;\n        V1:units = \nm/s\n ;\n        V1:grid = \ngrid\n ; // SGRID attribute\n        V1:location = \nedge2\n ; // SGRID attribute\n    float W(time, KMAX1, MMAXZ, NMAXZ) ;\n        W:long_name = \nW-omega per layer in zeta point\n ;\n        W:units = \nm/s\n ;\n        W:grid = \ngrid\n ; // SGRID attribute\n        W:location = \nface\n ; // SGRID attribute\n// SGRID variable\n    int grid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions = \nMMAX NMAX\n ;\n        grid:face_dimensions = \nMMAXZ: MMAX (padding: low) NMAXZ: NMAX (padding: low)\n ;\n        grid:node_coordinates = \nXCOR YCOR\n ;\n        grid:face_coordinates = \nXZ YZ\n ;\n        grid:vertical_dimensions = \nKMAX: KMAX1 (padding: none)\n ;\n\n// global attributes:\n        :title = \nHet Friesche Zeegaatje\n ;\n\ndata:\n KMAX = 1, 2, 3, 4, 5 ;\n KMAX1 = 0, 1, 2, 3, 4, 5 ;\n}\n\n\n\n\nThe edge_dimension attributes are not needed.\n\n\nROMS\n\uf0c1\n\n\nROMS uses also a C-grid, but it uses on the output file different dimensions for each staggered location.\nIn this case we need all attributes defined above including the edge\ni\n_dimension attributes.\n\n\nnetcdf sed023_last {\ndimensions:\n    ocean_time = UNLIMITED ; // (1 currently)\n    s_w = 21 ;\n    eta_rho = 60 ;\n    xi_rho = 160 ;\n    tracer = 10 ;\n    s_rho = 20 ;\n    eta_u = 60 ;\n    xi_u = 159 ;\n    eta_v = 59 ;\n    xi_v = 160 ;\n    eta_psi = 59 ;\n    xi_psi = 159 ;\nvariables:\n    double lat_psi(eta_psi, xi_psi) ;\n        lat_psi:long_name = \nlatitude of PSI-points\n ;\n        lat_psi:units = \ndegree_north\n ;\n    double lat_rho(eta_rho, xi_rho) ;\n        lat_rho:long_name = \nlatitude of RHO-points\n ;\n        lat_rho:units = \ndegree_north\n ;\n    double lat_u(eta_u, xi_u) ;\n        lat_u:long_name = \nlatitude of U-points\n ;\n        lat_u:units = \ndegree_north\n ;\n    double lat_v(eta_v, xi_v) ;\n        lat_v:long_name = \nlatitude of V-points\n ;\n        lat_v:units = \ndegree_north\n ;\n    double lon_psi(eta_psi, xi_psi) ;\n        lon_psi:long_name = \nlongitude of PSI-points\n ;\n        lon_psi:units = \ndegree_east\n ;\n    double lon_rho(eta_rho, xi_rho) ;\n        lon_rho:long_name = \nlongitude of RHO-points\n ;\n        lon_rho:units = \ndegree_east\n ;\n    double lon_u(eta_u, xi_u) ;\n        lon_u:long_name = \nlongitude of U-points\n ;\n        lon_u:units = \ndegree_east\n ;\n    double lon_v(eta_v, xi_v) ;\n        lon_v:long_name = \nlongitude of V-points\n ;\n        lon_v:units = \ndegree_east\n ;\n    double ocean_time(ocean_time) ;\n        ocean_time:long_name = \ntime since initialization\n ;\n        ocean_time:units = \nseconds since 1968-05-23 00:00:00 GMT\n ;\n        ocean_time:calendar = \ngregorian\n ;\n    double s_rho(s_rho) ;\n        s_rho:long_name = \nS-coordinate at RHO-points\n ;\n        s_rho:valid_min = -1. ;\n        s_rho:valid_max = 0. ;\n        s_rho:standard_name = \nocean_s_coordinate\n ;\n        s_rho:formula_terms = \ns: s_rho eta: zeta depth: h a: theta_s b: theta_b depth_c: hc\n ;\n    double s_w(s_w) ;\n        s_w:long_name = \nS-coordinate at W-points\n ;\n        s_w:valid_min = -1. ;\n        s_w:valid_max = 0. ;\n        s_w:standard_name = \nocean_s_coordinate\n ;\n        s_w:formula_terms = \ns: s_w eta: zeta depth: h a: theta_s b: theta_b depth_c: hc\n ;\n    float u(ocean_time, s_rho, eta_u, xi_u) ;\n        u:long_name = \nu-momentum component\n ;\n        u:units = \nmeter second-1\n ;\n        u:coordinates = \nlat_u lon_u\n ;\n        u:grid = \ngrid\n ; // SGRID attribute\n        u:location = \nedge1\n ; // SGRID attribute\n    float v(ocean_time, s_rho, eta_v, xi_v) ;\n        v:long_name = \nv-momentum component\n ;\n        v:units = \nmeter second-1\n ;\n        v:coordinates = \nlat_v lon_v\n ;\n        v:grid = \ngrid\n ; // SGRID attribute\n        v:location = \nedge2\n ; // SGRID attribute\n    float zeta(ocean_time, eta_rho, xi_rho) ;\n        zeta:long_name = \nfree-surface\n ;\n        zeta:units = \nmeter\n ;\n        zeta:time = \nocean_time\n ;\n        zeta:coordinates = \nlat_rho lon_rho\n ;\n        zeta:grid = \ngrid\n ; // SGRID attribute\n        zeta:location = \nface\n ; // SGRID attribute\n// SGRID variable\n    int grid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions = \nxi_psi eta_psi\n ;\n        grid:face_dimensions = \nxi_rho: xi_psi (padding: both) eta_rho: eta_psi (padding: both)\n ;\n        grid:edge1_dimensions = \nxi_u: xi_psi eta_u: eta_psi (padding: both)\n ;\n        grid:edge2_dimensions = \nxi_v: xi_psi (padding: both) eta_v: eta_psi\n ;\n        grid:node_coordinates = \nlon_psi lat_psi\n ;\n        grid:face_coordinates = \nlon_rho lat_rho\n ;\n        grid:edge1_coordinates = \nlon_u lat_u\n ;\n        grid:edge2_coordinates = \nlon_v lat_v\n ;\n        grid:vertical_dimensions = \ns_rho: s_w (padding: none)\n ;\n\n// global attributes:\n        :Conventions = \nCF-1.0\n ;\n        :title = \nROMS/TOMS 2.2 - Adria02 Uber Run\n ;\n}\n\n\n\n\nWRF (ARW version)\n\uf0c1\n\n\nThe WRF-ARW also uses a C-grid.\nAgain the model results can best be captured by a 2D grid.\nIt might be interesting to verify the result for WRF-NMM since that model uses an E-grid,\nbut I couldn\nt find an example file.\n\n\nnetcdf wrfout_v2_Lambert {\ndimensions:\n    Time = UNLIMITED ; // (13 currently)\n    DateStrLen = 19 ;\n    west_east = 73 ;\n    south_north = 60 ;\n    west_east_stag = 74 ;\n    bottom_top = 27 ;\n    south_north_stag = 61 ;\n    bottom_top_stag = 28 ;\n\nvariables:\n    char Times(Time, DateStrLen) ;\n    float U(Time, bottom_top, south_north, west_east_stag) ;\n        U:description = \nx-wind component\n ;\n        U:units = \nm s-1\n ;\n        U:grid = \ngrid\n ; // SGRID attribute\n        U:location = \nedge1\n ; // SGRID attribute\n    float V(Time, bottom_top, south_north_stag, west_east) ;\n        V:description = \ny-wind component\n ;\n        V:units = \nm s-1\n ;\n        V:grid = \ngrid\n ; // SGRID attribute\n        U:location = \nedge2\n ; // SGRID attribute\n    float W(Time, bottom_top_stag, south_north, west_east) ;\n        W:description = \nz-wind component\n ;\n        W:units = \nm s-1\n ;\n        W:grid = \ngrid\n ; // SGRID attribute\n        W:location = \nface\n ; // SGRID attribute\n    float T(Time, bottom_top, south_north, west_east) ;\n        T:description = \nperturbation potential temperature (theta-t0)\n ;\n        T:units = \nK\n ;\n        W:grid = \ngrid\n ; // SGRID attribute\n        W:location = \nface\n ; // SGRID attribute\n    float XLAT(Time, south_north, west_east) ;\n        XLAT:description = \nLATITUDE, SOUTH IS NEGATIVE\n ;\n        XLAT:units = \ndegree_north\n ;\n    float XLONG(Time, south_north, west_east) ;\n        XLONG:description = \nLONGITUDE, WEST IS NEGATIVE\n ;\n        XLONG:units = \ndegree_east\n ;\n    float ZNU(Time, bottom_top) ;\n        ZNU:description = \neta values on half (mass) levels\n ;\n        ZNU:units = \n ;\n    float ZNW(Time, bottom_top_stag) ;\n        ZNW:description = \neta values on full (w) levels\n ;\n        ZNW:units = \n ;\n// SGRID variable\n    int grid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions = \nwest_east_stag south_north_stag bottom_top_stag\n ;\n        grid:face_dimensions = \nwest_east: west_east_stag (padding: none) south_north: south_north_stag (padding: none)\n ;\n        grid:face_coordinates = \nXLONG XLAT\n ; // what to do with ZNU/ZNW vertical coordinates?\n        grid:vertical_dimensions = \nbottom_top: bottom_top_stag (padding: none)\n ;\n\n// global attributes:\n        :TITLE = \nOUTPUT FROM WRF V2.0 MODEL\n ;\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#sgrid-conventions-v02", 
            "text": "Following the success of the  UGRID conventions ,\nBert Jagers created conventions for staggered data on structured grids that are consistent with the UGRID conventions.\nWe refer to these as the SGRID conventions, described below.", 
            "title": "SGRID Conventions (v0.2)"
        }, 
        {
            "location": "/#introduction", 
            "text": "The  CF-conventions  are widely used for storing and distributing environmental / earth sciences / climate data. The CF-conventions use a data perspective: every data value points to the latitude and longitude at which that value has been defined; the combination of latitude and longitude bounds and cell methods attributes can be used to define spatially averaged rather than point values.   This is all great for the distribution of (interpolated) data for general visualization and spatial data processing,\nbut it doesn t capture the relationship of the variables as computed by a numerical model (such as  Arakawa staggering ). Many models use staggered grids (using finite differences, or finite volume approach) or use a finite element approach of which the correct meaning may not be captured easily by simple cell methods descriptors.\nThis becomes a problem if you don t want to just look at the big picture of the model results,\nbut also at the details at the grid resolution:  What is the exact meaning of a flux on the output file in discrete terms?  Can we verify the mass balance?\n* Can the data be used for restarting the model?  Correctly handling the staggered data has always been a crucial element of model post-processing tools. In the UGRID conventions, we have defined the (unstructured) grid as a separate entity on the file which consists of nodes and connections of nodes defining edges, faces, and volumes.\nFor a structured (staggered) grid we are currently lacking a consistent convention. Although one could store structured grid data using UGRID conventions,\nsome fundamental aspects such as distinction between grid directions would be lost.  In this context we have created these lightweight SGRID conventions to define the core aspects of a structured staggered grid without trying to capture the details of finite element formulations.\nThis is an attempt to bring conventions for structured grids on par with those for unstructured grids.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#conventions", 
            "text": "Consistent with the UGRID conventions we use the following terms for points,\nlines, and cells that make up a grid.     Dimensionality  Name  Comments      0  node  A point, a coordinate pair or triplet: the most basic element of the topology (also known as  vertex ).    1  edge  A line or curve bounded by two nodes.    2  face  A plane or surface enclosed by a set of edges. In a Cartesian 2D model, you might refer to this as a  cell  or  square .    3  volume  A volume enclosed by a set of faces.     In the UGRID conventions the focus is on describing the topology of the mesh (connectivity of the nodes, edges, faces, and volumes as appropriate).\nThe topology of a structured grid is inherently defined;\nthe focus for the SGRID conventions is therefore on the numbering used.\nStill we need to distinguish between 2D and 3D grids (1D conventions may be defined consistently).", 
            "title": "Conventions"
        }, 
        {
            "location": "/#2d-grid", 
            "text": "Required topology attributes  Value      vertical_dimensions     topology_dimension  2        Optional attributes  Default value      node_dimensions  node_dimension1 node_dimension2    node_coordinates     face_dimensions  face_dimension1:node_dimension1 (padding: type1 ) face_dimension2:node_dimension2 (padding: type2 )    face_coordinate     edge2_dimensions  face_dimension1:node_dimension1 (padding: type1 ) node_dimension2    edge2_coordinates     edge1_dimensions  node_dimension1 face_dimension2:node_dimension2 (padding: type2 )    edge1_coordinates     cf_role  grid_topology     where the padding type may be one of the four literal strings: none ,  low ,  high , or  both  depending on whether the face_dimension is one shorter than the corresponding node_dimension (padding:none),\none longer than the corresponding node_dimension (padding:both),\nor of equal length with one extra value stored on the low or high end of the dimension (see the figure below).\nThe edge1_dimensions and edge2_dimensions attributes may be used to define separate dimensions for the edges (see the ROMS example below),\nbut by default the edge dimensions are assumed to be consistent with the dimensions used by the edges and faces respectively.\nThe optional vertical_dimensions attribute may be used to specify the names of the dimensions for the layers and layer interfaces respectively using the same syntax:\nlayer_dimension:layer_interface_dimension (padding: type ).  Note:   The numbering of the edges corresponds to the order of the dimensions in the dimensions attributes.\n  The order of the dimensions listed here does not change since these are specified as a string.\n  The actual order of dimensions in the netCDF API (and hence in the dump generated by different tools) depends on the programming language used.\n  Hence, the order of the dimensions listed here may differ from the order of the dimensions in the data definition.   \nFigure 1: illustrating the formulations used for expressing the relationship between face/edge and node dimensions. Please note that the numbering of the faces and nodes can be adjusted using face(face) and node(node) coordinate variables.  Example:  dimensions:\n    time = UNLIMITED ;\n    inode = 10 ;\n    jnode = 20 ;\n    icell = 9 ;\n    jcell = 19 ;\n\nvariables:\n    char time(time) ;\n        time:standard_name =  time  ;\n        time:long_name =  time  ;\n        time:units =  seconds since 2015-01-01 00:00:00  ;\n    float u(time, jcell, inode) ;\n        u:description =  x-velocity  ;\n        u:units =  m s-1  ;\n        u:grid =  MyGrid  ;\n        u:location =  edge1  ;\n    float v(time, jnode, icell) ;\n        u:description =  y-velocity  ;\n        u:units =  m s-1  ;\n        u:grid =  MyGrid  ;\n        u:location =  edge2  ;\n    float c(time, jcell, icell) ;\n        c:description =  some concentration  ;\n        c:grid =  MyGrid  ;\n        c:location =  face  ;\n    float node_lat(jnode, inode) ;\n        node_lat:standard_name =  latitude  ;\n        node_lat:units =  degree_north  ;\n    float node_lon(jnode, inode) ;\n        node_lon:standard_name =  longitude  ;\n        node_lon:units =  degree_east  ;\n\n    int MyGrid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions =  inode jnode  ;\n        grid:face_dimensions =  icell: inode (padding: none) jcell: jnode (padding: none)  ;\n        grid:node_coordinates =  node_lon node_lat  ;", 
            "title": "2D grid"
        }, 
        {
            "location": "/#3d-grid", 
            "text": "Required topology attributes  Value      topology_dimension  3        Optional attributes  Default value      volume_dimensions  face_dimension1:node_dimension1 (padding: type1 ) face_dimension2:node_dimension2 (padding: type2 ) face_dimension3:node_dimension3 (padding: type3 )    face3_dimensions  face_dimension1:node_dimension1 (padding: type1 ) face_dimension2:node_dimension2 (padding: type2 ) node_dimension3    edge1_dimensions  face_dimension1:node_dimension1 (padding: type1 ) node_dimension2 node_dimension3    face2_dimensions  face_dimension1:node_dimension1 (padding: type1 ) node_dimension2 face_dimension3:node_dimension3 (padding: type3 )    cf_role  grid_topology    edge2_dimensions  node_dimension1 face_dimension2:node_dimension2 (padding: type2 ) node_dimension3    edge3_dimensions  node_dimension1 node_dimension2 face_dimension3:node_dimension3 (padding: type3 )    node_dimensions  node_dimension1 node_dimension2 node_dimension3    face1_dimensions  node_dimension1 face_dimension2:node_dimension2 (padding: type2 ) face_dimension3:node_dimension3 (padding: type3 )    node_coordinates     edge i _coordinates     face i _coordinates     volume_coordinates      Notes:   The edge1, edge2, and edge3 are in a 3D grid aligned to the dimensions1, 2, and 3 respectively,\n  whereas the edge1 and edge2 are in a 2D grid perpendicular to the dimensions 1 and 2 respectively.\n  The face1, face2, and face3 play that role in the 3D grid.  The 3d grid option should not be used be used for layered grids,\n  such as typical ocean and atmosphere models.\n  Use the 2d grid with vertical dimensions instead.\n  This allows 2D quantities (such as surface quantities) and 3D quantities to be linked to the same mesh.   Example:  dimensions:\n    time = UNLIMITED ;\n    inode = 10 ;\n    jnode = 20 ;\n    knode = 30 ;\n    iface = 9 ;\n    jface = 19 ;\n    kface = 29 ;\n\nvariables:\n    char time(time) ;\n        time:standard_name =  time  ;\n        time:long_name =  time  ;\n        time:units =  seconds since 2015-01-01 00:00:00  ;\n    float u(time, kface, jface, inode) ;\n        u:description =  x-velocity  ;\n        u:units =  m s-1  ;\n        u:grid =  MyGrid3  ;\n        u:location =  face1  ;\n    float v(time, kface, jnode, iface) ;\n        u:description =  y-velocity  ;\n        u:units =  m s-1  ;\n        u:grid =  MyGrid3  ;\n        u:location =  face2  ;\n    float w(time, knode, jface, iface) ;\n        u:description =  z-velocity  ;\n        u:units =  m s-1  ;\n        u:grid =  MyGrid3  ;\n        u:location =  face3  ;\n    float c(time, kface, jface, iface) ;\n        c:description =  some concentration  ;\n        c:grid =  MyGrid3  ;\n        c:location =  volume  ;\n    float node_lat(knode, jnode, inode) ;\n        node_lat:standard_name =  latitude  ;\n        node_lat:units =  degree_north  ;\n    float node_lon(knode, jnode, inode) ;\n        node_lon:standard_name =  longitude  ;\n        node_lon:units =  degree_east  ;\n    float node_elevation(knode, jnode, inode) ;\n        node_elevation:description =  elevation  ;\n        node_elevation:units =  m  ;\n\n    int MyGrid3 ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 3 ;\n        grid:node_dimensions =  inode jnode knode  ;\n        grid:volume_dimensions =  iface: inode (padding: none) jface: jnode (padding: none) kface: knode (padding: none)  ;\n        grid:node_coordinates =  node_lon node_lat node_elevation  ;", 
            "title": "3D grid"
        }, 
        {
            "location": "/#data-variables", 
            "text": "The use of the attributes to associate a data variable with a specific grid and stagger location is copied from the UGRID conventions:\nTo map the variable onto the topology of the underlying grid,\ntwo new attributes have been introduced.\nFirst, the attribute  grid  points to the grid_topology variable containing the meta-data attributes of the grid on which the variable has been defined.\nSecond, the attribute  location  points to the (stagger) location within the grid at which the variable is defined.  Example:  double waterlevel(time,j,i) ;\n        waterlevel:standard_name =  sea_surface_height_above_geoid  ;\n        waterlevel:units =  m  ;\n        waterlevel:grid =  MyGrid \n        waterlevel:location =  face  ;\n        waterlevel:coordinates =  lat_face_MyGrid lon_face_MyGrid  ;", 
            "title": "Data variables"
        }, 
        {
            "location": "/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/#delft3d", 
            "text": "Delft3D uses an Arikawa C-grid with the water level (pressure) computed in the cell centres,\nand the normal velocities at the cell edges.\nThis example shows the use of asymmetric padding (at the low end of the horizontal coordinate indices there is an extra line of face/mid-point values).\nIn the vertical there is no padding, so the number of layer interfaces is one more than the number of layers.\nThe integer coodinate variables KMAX and KMAX1 are used to indicate that layer interfaces are numbered 0 to KMAX whereas all other indices use the default numbering from 1 to the maximum value.  netcdf trim-f34 {\ndimensions:\n    NMAX = 22 ;\n    NMAXZ = 22 ;\n    MMAX = 15 ;\n    MMAXZ = 15 ;\n    KMAX = 5 ;\n    KMAX1 = 6 ;\n    time = UNLIMITED ; // (6 currently)\nvariables:\n    int KMAX(KMAX) ;\n    int KMAX1(KMAX1) ;\n    float XCOR(MMAX, NMAX) ;\n        XCOR:standard_name =  projection_x_coordinate  ;\n        XCOR:long_name =  X-coordinate of grid points  ;\n        XCOR:units =  m  ;\n    float YCOR(MMAX, NMAX) ;\n        YCOR:standard_name =  projection_y_coordinate  ;\n        YCOR:long_name =  Y-coordinate of grid points  ;\n        YCOR:units =  m  ;\n    float XZ(MMAXZ, NMAXZ) ;\n        XZ:standard_name =  projection_x_coordinate  ;\n        XZ:long_name =  X-coordinate of cell centres  ;\n        XZ:units =  m  ;\n    float YZ(MMAXZ, NMAXZ) ;\n        YZ:standard_name =  projection_y_coordinate  ;\n        YZ:long_name =  Y-coordinate of cell centres  ;\n        YZ:units =  m  ;\n    float THICK(KMAX) ;\n        THICK:long_name =  Fraction part of layer thickness of total water-height  ;\n        THICK:units =  [ .01*% ]  ;\n    float time(time) ;\n        time:standard_name =  time  ;\n        time:long_name =  time  ;\n        time:units =  seconds since 1990-08-05 00:00:00  ;\n    float S1(time, MMAXZ, NMAXZ) ;\n        S1:long_name =  Water-level in zeta point  ;\n        S1:units =  m  ;\n        S1:coordinates =  XZ YZ  ;\n        S1:grid =  grid  ; // SGRID attribute\n        S1:location =  face  ; // SGRID attribute\n    float U1(time, KMAX, MMAX, NMAXZ) ;\n        U1:long_name =  U-velocity per layer in U-point (Eulerian)  ;\n        U1:units =  m/s  ;\n        U1:grid =  grid  ; // SGRID attribute\n        U1:location =  edge1  ; // SGRID attribute\n    float V1(time, KMAX, MMAXZ, NMAX) ;\n        V1:long_name =  V-velocity per layer in V-point (Eulerian)  ;\n        V1:units =  m/s  ;\n        V1:grid =  grid  ; // SGRID attribute\n        V1:location =  edge2  ; // SGRID attribute\n    float W(time, KMAX1, MMAXZ, NMAXZ) ;\n        W:long_name =  W-omega per layer in zeta point  ;\n        W:units =  m/s  ;\n        W:grid =  grid  ; // SGRID attribute\n        W:location =  face  ; // SGRID attribute\n// SGRID variable\n    int grid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions =  MMAX NMAX  ;\n        grid:face_dimensions =  MMAXZ: MMAX (padding: low) NMAXZ: NMAX (padding: low)  ;\n        grid:node_coordinates =  XCOR YCOR  ;\n        grid:face_coordinates =  XZ YZ  ;\n        grid:vertical_dimensions =  KMAX: KMAX1 (padding: none)  ;\n\n// global attributes:\n        :title =  Het Friesche Zeegaatje  ;\n\ndata:\n KMAX = 1, 2, 3, 4, 5 ;\n KMAX1 = 0, 1, 2, 3, 4, 5 ;\n}  The edge_dimension attributes are not needed.", 
            "title": "Delft3D"
        }, 
        {
            "location": "/#roms", 
            "text": "ROMS uses also a C-grid, but it uses on the output file different dimensions for each staggered location.\nIn this case we need all attributes defined above including the edge i _dimension attributes.  netcdf sed023_last {\ndimensions:\n    ocean_time = UNLIMITED ; // (1 currently)\n    s_w = 21 ;\n    eta_rho = 60 ;\n    xi_rho = 160 ;\n    tracer = 10 ;\n    s_rho = 20 ;\n    eta_u = 60 ;\n    xi_u = 159 ;\n    eta_v = 59 ;\n    xi_v = 160 ;\n    eta_psi = 59 ;\n    xi_psi = 159 ;\nvariables:\n    double lat_psi(eta_psi, xi_psi) ;\n        lat_psi:long_name =  latitude of PSI-points  ;\n        lat_psi:units =  degree_north  ;\n    double lat_rho(eta_rho, xi_rho) ;\n        lat_rho:long_name =  latitude of RHO-points  ;\n        lat_rho:units =  degree_north  ;\n    double lat_u(eta_u, xi_u) ;\n        lat_u:long_name =  latitude of U-points  ;\n        lat_u:units =  degree_north  ;\n    double lat_v(eta_v, xi_v) ;\n        lat_v:long_name =  latitude of V-points  ;\n        lat_v:units =  degree_north  ;\n    double lon_psi(eta_psi, xi_psi) ;\n        lon_psi:long_name =  longitude of PSI-points  ;\n        lon_psi:units =  degree_east  ;\n    double lon_rho(eta_rho, xi_rho) ;\n        lon_rho:long_name =  longitude of RHO-points  ;\n        lon_rho:units =  degree_east  ;\n    double lon_u(eta_u, xi_u) ;\n        lon_u:long_name =  longitude of U-points  ;\n        lon_u:units =  degree_east  ;\n    double lon_v(eta_v, xi_v) ;\n        lon_v:long_name =  longitude of V-points  ;\n        lon_v:units =  degree_east  ;\n    double ocean_time(ocean_time) ;\n        ocean_time:long_name =  time since initialization  ;\n        ocean_time:units =  seconds since 1968-05-23 00:00:00 GMT  ;\n        ocean_time:calendar =  gregorian  ;\n    double s_rho(s_rho) ;\n        s_rho:long_name =  S-coordinate at RHO-points  ;\n        s_rho:valid_min = -1. ;\n        s_rho:valid_max = 0. ;\n        s_rho:standard_name =  ocean_s_coordinate  ;\n        s_rho:formula_terms =  s: s_rho eta: zeta depth: h a: theta_s b: theta_b depth_c: hc  ;\n    double s_w(s_w) ;\n        s_w:long_name =  S-coordinate at W-points  ;\n        s_w:valid_min = -1. ;\n        s_w:valid_max = 0. ;\n        s_w:standard_name =  ocean_s_coordinate  ;\n        s_w:formula_terms =  s: s_w eta: zeta depth: h a: theta_s b: theta_b depth_c: hc  ;\n    float u(ocean_time, s_rho, eta_u, xi_u) ;\n        u:long_name =  u-momentum component  ;\n        u:units =  meter second-1  ;\n        u:coordinates =  lat_u lon_u  ;\n        u:grid =  grid  ; // SGRID attribute\n        u:location =  edge1  ; // SGRID attribute\n    float v(ocean_time, s_rho, eta_v, xi_v) ;\n        v:long_name =  v-momentum component  ;\n        v:units =  meter second-1  ;\n        v:coordinates =  lat_v lon_v  ;\n        v:grid =  grid  ; // SGRID attribute\n        v:location =  edge2  ; // SGRID attribute\n    float zeta(ocean_time, eta_rho, xi_rho) ;\n        zeta:long_name =  free-surface  ;\n        zeta:units =  meter  ;\n        zeta:time =  ocean_time  ;\n        zeta:coordinates =  lat_rho lon_rho  ;\n        zeta:grid =  grid  ; // SGRID attribute\n        zeta:location =  face  ; // SGRID attribute\n// SGRID variable\n    int grid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions =  xi_psi eta_psi  ;\n        grid:face_dimensions =  xi_rho: xi_psi (padding: both) eta_rho: eta_psi (padding: both)  ;\n        grid:edge1_dimensions =  xi_u: xi_psi eta_u: eta_psi (padding: both)  ;\n        grid:edge2_dimensions =  xi_v: xi_psi (padding: both) eta_v: eta_psi  ;\n        grid:node_coordinates =  lon_psi lat_psi  ;\n        grid:face_coordinates =  lon_rho lat_rho  ;\n        grid:edge1_coordinates =  lon_u lat_u  ;\n        grid:edge2_coordinates =  lon_v lat_v  ;\n        grid:vertical_dimensions =  s_rho: s_w (padding: none)  ;\n\n// global attributes:\n        :Conventions =  CF-1.0  ;\n        :title =  ROMS/TOMS 2.2 - Adria02 Uber Run  ;\n}", 
            "title": "ROMS"
        }, 
        {
            "location": "/#wrf-arw-version", 
            "text": "The WRF-ARW also uses a C-grid.\nAgain the model results can best be captured by a 2D grid.\nIt might be interesting to verify the result for WRF-NMM since that model uses an E-grid,\nbut I couldn t find an example file.  netcdf wrfout_v2_Lambert {\ndimensions:\n    Time = UNLIMITED ; // (13 currently)\n    DateStrLen = 19 ;\n    west_east = 73 ;\n    south_north = 60 ;\n    west_east_stag = 74 ;\n    bottom_top = 27 ;\n    south_north_stag = 61 ;\n    bottom_top_stag = 28 ;\n\nvariables:\n    char Times(Time, DateStrLen) ;\n    float U(Time, bottom_top, south_north, west_east_stag) ;\n        U:description =  x-wind component  ;\n        U:units =  m s-1  ;\n        U:grid =  grid  ; // SGRID attribute\n        U:location =  edge1  ; // SGRID attribute\n    float V(Time, bottom_top, south_north_stag, west_east) ;\n        V:description =  y-wind component  ;\n        V:units =  m s-1  ;\n        V:grid =  grid  ; // SGRID attribute\n        U:location =  edge2  ; // SGRID attribute\n    float W(Time, bottom_top_stag, south_north, west_east) ;\n        W:description =  z-wind component  ;\n        W:units =  m s-1  ;\n        W:grid =  grid  ; // SGRID attribute\n        W:location =  face  ; // SGRID attribute\n    float T(Time, bottom_top, south_north, west_east) ;\n        T:description =  perturbation potential temperature (theta-t0)  ;\n        T:units =  K  ;\n        W:grid =  grid  ; // SGRID attribute\n        W:location =  face  ; // SGRID attribute\n    float XLAT(Time, south_north, west_east) ;\n        XLAT:description =  LATITUDE, SOUTH IS NEGATIVE  ;\n        XLAT:units =  degree_north  ;\n    float XLONG(Time, south_north, west_east) ;\n        XLONG:description =  LONGITUDE, WEST IS NEGATIVE  ;\n        XLONG:units =  degree_east  ;\n    float ZNU(Time, bottom_top) ;\n        ZNU:description =  eta values on half (mass) levels  ;\n        ZNU:units =   ;\n    float ZNW(Time, bottom_top_stag) ;\n        ZNW:description =  eta values on full (w) levels  ;\n        ZNW:units =   ;\n// SGRID variable\n    int grid ;\n        grid:cf_role = grid_topology\n        grid:topology_dimension = 2 ;\n        grid:node_dimensions =  west_east_stag south_north_stag bottom_top_stag  ;\n        grid:face_dimensions =  west_east: west_east_stag (padding: none) south_north: south_north_stag (padding: none)  ;\n        grid:face_coordinates =  XLONG XLAT  ; // what to do with ZNU/ZNW vertical coordinates?\n        grid:vertical_dimensions =  bottom_top: bottom_top_stag (padding: none)  ;\n\n// global attributes:\n        :TITLE =  OUTPUT FROM WRF V2.0 MODEL  ;\n}", 
            "title": "WRF (ARW version)"
        }
    ]
}